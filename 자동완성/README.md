`https://programmers.co.kr/tos`

#coding_test #2019_KAKAO_BLIND_RECRUITMENT

# 문제
###### 문제 설명

## 자동완성

포털 다음에서 검색어 자동완성 기능을 넣고 싶은 라이언은 한 번 입력된 문자열을 학습해서 다음 입력 때 활용하고 싶어 졌다. 예를 들어, `go` 가 한 번 입력되었다면, 다음 사용자는 `g` 만 입력해도 `go`를 추천해주므로 `o`를 입력할 필요가 없어진다! 단, 학습에 사용된 단어들 중 앞부분이 같은 경우에는 어쩔 수 없이 다른 문자가 나올 때까지 입력을 해야 한다.  
효과가 얼마나 좋을지 알고 싶은 라이언은 학습된 단어들을 찾을 때 몇 글자를 입력해야 하는지 궁금해졌다.

예를 들어, 학습된 단어들이 아래와 같을 때

```
go
gone
guild
```

- `go`를 찾을 때 `go`를 모두 입력해야 한다.
- `gone`을 찾을 때 `gon` 까지 입력해야 한다. (`gon`이 입력되기 전까지는 `go` 인지 `gone`인지 확신할 수 없다.)
- `guild`를 찾을 때는 `gu` 까지만 입력하면 `guild`가 완성된다.

이 경우 총 입력해야 할 문자의 수는 `7`이다.

라이언을 도와 위와 같이 문자열이 입력으로 주어지면 학습을 시킨 후, 학습된 단어들을 순서대로 찾을 때 몇 개의 문자를 입력하면 되는지 계산하는 프로그램을 만들어보자.

### 입력 형식

학습과 검색에 사용될 중복 없는 단어 `N`개가 주어진다.  
모든 단어는 알파벳 소문자로 구성되며 단어의 수 `N`과 단어들의 길이의 총합 `L`의 범위는 다음과 같다.

- 2 <= `N` <= 100,000
- 2 <= `L` <= 1,000,000

### 출력 형식

단어를 찾을 때 입력해야 할 총 문자수를 리턴한다.

### 입출력 예제

|words|result|
|---|---|
|["go","gone","guild"]|7|
|["abc","def","ghi","jklm"]|4|
|["word","war","warrior","world"]|15|

### 입출력 설명

- 첫 번째 예제는 본문 설명과 같다.
- 두 번째 예제에서는 모든 단어들이 공통된 부분이 없으므로, 가장 앞글자만 입력하면 된다.
- 세 번째 예제는 총 `15` 자를 입력해야 하고 설명은 아래와 같다.
    - `word`는 `word`모두 입력해야 한다.
    - `war`는 `war` 까지 모두 입력해야 한다.
    - `warrior`는 `warr` 까지만 입력하면 된다.
    - `world`는 `worl`까지 입력해야 한다. (`word`와 구분되어야 함을 명심하자)
# 문제풀이

이 문제는 [[트라이(Trie)|트라이(Trie)]]를 사용하여 해결할 수 있다. 트라이는 문자열을 저장하고 검색하는 데 적합한 트리 기반의 자료구조다. 각 노드는 다음 문자를 가리키는 자식 노드들을 갖는다. 이를 활용하여 각 단어를 입력할 때 필요한 최소한의 글자 수를 계산할 수 있다.

1. 각 단어를 트라이에 삽입한다. 
2. 각 노드는 해당 노드를 거쳐간 단어의 수를 카운트한다. 
3. 각 단어에 대해 트라이를 탐색하며, 다음 노드로 넘어가는 조건이 현재 노드를 거쳐간 단어의 수가 1보다 큰 경우이다. 해당 과정에서 각 단어를 탐색하는 데 필요한 글자 수를 카운트하여 더한다.
# 코드
```python
# 문제 해결을 위해 필요한 메소드를 Trie 클래스에 추가하고, 전체 로직을 재검토하겠습니다.
class TrieNode:
    def __init__(self):
        self.children = {}
        self.counter = 0  # 이 노드를 거쳐간 단어의 수를 세기 위한 카운터

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
            node.counter += 1  # 현재 노드를 거치는 단어 수 증가

    def count_inputs(self, words):
        total_count = 0
        for word in words:
            node = self.root
            count = 0
            for char in word:
                # 더 이상 구분할 필요가 없거나 마지막 문자에 도달하면 중지
                if node.counter == 1:
                    break
                node = node.children[char]
                count += 1
            total_count += count
        return total_count

def solution(words):
    trie = Trie()
    # 모든 단어를 트라이에 삽입
    for word in words:
        trie.insert(word)

    # 각 단어를 찾기 위해 입력해야 하는 최소한의 문자 수 계산
    return trie.count_inputs(words)

# 예제 입력으로 테스트
example_words = ["go", "gone", "guild"]
result = solution(example_words)
result
```

# 점수
정확성  테스트

|   |   |
|---|---|
|테스트 1 〉|통과 (0.01ms, 10.4MB)|
|테스트 2 〉|통과 (0.02ms, 10.2MB)|
|테스트 3 〉|통과 (0.01ms, 10.3MB)|
|테스트 4 〉|통과 (0.02ms, 10.2MB)|
|테스트 5 〉|통과 (0.04ms, 10.3MB)|
|테스트 6 〉|통과 (3194.42ms, 275MB)|
|테스트 7 〉|통과 (0.02ms, 10.3MB)|
|테스트 8 〉|통과 (2895.36ms, 275MB)|
|테스트 9 〉|통과 (0.02ms, 10.2MB)|
|테스트 10 〉|통과 (0.02ms, 10.4MB)|
|테스트 11 〉|통과 (0.02ms, 10.3MB)|
|테스트 12 〉|통과 (3210.70ms, 275MB)|
|테스트 13 〉|통과 (3095.62ms, 275MB)|
|테스트 14 〉|통과 (2289.87ms, 398MB)|
|테스트 15 〉|통과 (0.03ms, 10.2MB)|
|테스트 16 〉|통과 (2868.89ms, 275MB)|
|테스트 17 〉|통과 (2793.19ms, 275MB)|
|테스트 18 〉|통과 (0.03ms, 10.2MB)|
|테스트 19 〉|통과 (2615.58ms, 398MB)|
|테스트 20 〉|통과 (2880.52ms, 275MB)|
|테스트 21 〉|통과 (2234.96ms, 398MB)|
|테스트 22 〉|통과 (2169.45ms, 398MB)|

채점 결과

정확성: 100.0

합계: 100.0 / 100.0