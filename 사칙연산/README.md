`https://programmers.co.kr/tos`

#coding_test #Dynamic_Prgramming

# 문제
###### 문제 설명

사칙연산에서 더하기(+)는 결합법칙이 성립하지만, 빼기(-)는 결합법칙이 성립하지 않습니다.  
예를 들어 식 1 - 5 - 3은 연산 순서에 따라 다음과 같이 다른 결과를 가집니다.

- ((1 - 5) - 3) = -7
- (1 - (5 - 3)) = -1

위 예시와 같이 뺄셈은 연산 순서에 따라 그 결과가 바뀔 수 있습니다.  
또 다른 예로 식 1 - 3 + 5 - 8은 연산 순서에 따라 다음과 같이 5가지 결과가 나옵니다.

- (((1 - 3) + 5) - 8) = -5
- ((1 - (3 + 5)) - 8) = -15
- (1 - ((3 + 5) - 8)) = 1
- (1 - (3 + (5 - 8))) = 1
- ((1 - 3) + (5 - 8)) = -5

위와 같이 서로 다른 연산 순서의 계산 결과는 `[-15, -5, -5, 1, 1]`이 되며, 이중 최댓값은 1입니다.  
문자열 형태의 숫자와, 더하기 기호("+"), 뺄셈 기호("-")가 들어있는 배열 arr가 매개변수로 주어질 때, 서로 다른 연산순서의 계산 결과 중 최댓값을 return 하도록 solution 함수를 완성해 주세요.

##### 제한 사항

- arr는 두 연산자 "+", "-" 와 숫자가 들어있는 배열이며, 길이는 3 이상 201 이하 입니다.
    - arr의 길이는 항상 홀수입니다.
    - arr에 들어있는 숫자의 개수는 2개 이상 101개 이하이며, 연산자의 개수는 (숫자의 개수) -1 입니다.
    - 숫자는 1 이상 1,000 이하의 자연수가 문자열 형태로 들어있습니다.. (ex : "456")
- 배열의 첫 번째 원소와 마지막 원소는 반드시 숫자이며, 숫자와 연산자가 항상 번갈아가며 들어있습니다.

---

##### 입출력 예

|arr|result|
|---|---|
|["1", "-", "3", "+", "5", "-", "8"]|1|
|["5", "-", "3", "+", "1", "+", "2", "-", "4"]|3|

##### 입출력 예시

입출력 예 #1  
위의 예시와 같이 (1-(3+(5-8))) = 1 입니다.

입출력 예 #2  
(5-(3+((1+2)-4))) = 3 입니다.
# 문제풀이

[[동적 계획법(Dynamic Programming)|동적 프로그래밍(DP)]]으로 문제를 해결하기 위해서는 먼저 서브표현식의 최댓값과 최솟값을 저장하는 2차원 배열을 생성해야 한다. 이 배열을 활용해 큰 표현식의 최댓값을 계산한다. 이 방법은 작은 문제의 해답을 기반으로 큰 문제의 해답을 구축하는 DP의 기본 원칙을 따른다.

DP 접근 방식의 주요 단계는 다음과 같다:

1. 초기화: 숫자만 존재하는 경우, 최대값과 최솟값은 숫자 그 자체이다.
2. 서브표현식 계산: 더 작은 서브표현식의 결과를 활용해 더 큰 표현식의 결과를 계산한다.
3. 결합: 더하기와 뺄셈 연산을 적용해 최댓값과 최솟값을 결합한다.

이러한 절차를 통해, 복잡한 표현식의 최댓값과 최솟값을 효율적으로 찾아낼 수 있다.
# 코드
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm> // std::max, std::min 사용
#include <climits>   // INT_MAX, INT_MIN 사용

using namespace std;

int solution(vector<string> arr) {
    int n = (arr.size() + 1) / 2; // 숫자의 개수
    vector<vector<int>> maxDP(n, vector<int>(n, INT_MIN)); // 최댓값 저장
    vector<vector<int>> minDP(n, vector<int>(n, INT_MAX)); // 최솟값 저장

    // 숫자만 있는 경우 초기화
    for (int i = 0; i < n; i++) {
        int num = stoi(arr[i * 2]);
        maxDP[i][i] = num;
        minDP[i][i] = num;
    }

    // 서브표현식을 통해 DP 테이블 채우기
    for (int len = 2; len <= n; len++) { // 서브표현식의 길이
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            for (int k = i; k < j; k++) {
                int left = k;
                int right = k + 1;
                int opIndex = 2 * k + 1;

                if (arr[opIndex] == "+") {
                    maxDP[i][j] = max(maxDP[i][j], maxDP[i][left] + maxDP[right][j]);
                    minDP[i][j] = min(minDP[i][j], minDP[i][left] + minDP[right][j]);
                } else { // "-"
                    maxDP[i][j] = max(maxDP[i][j], maxDP[i][left] - minDP[right][j]);
                    minDP[i][j] = min(minDP[i][j], minDP[i][left] - maxDP[right][j]);
                }
            }
        }
    }

    return maxDP[0][n - 1]; // 전체 표현식에 대한 최댓값 반환
}

int main() {
    vector<string> arr1 = {"1", "-", "3", "+", "5", "-", "8"};
    cout << "Maximum result of [\"1\", \"-\", \"3\", \"+\", \"5\", \"-\", \"8\"]: " << solution(arr1) << endl;

    vector<string> arr2 = {"5", "-", "3", "+", "1", "+", "2", "-", "4"};
    cout << "Maximum result of [\"5\", \"-\", \"3\", \"+\", \"1\", \"+\", \"2\", \"-\", \"4\"]: " << solution(arr2) << endl;

    return 0;
}

```

# 점수

정확성  테스트

|   |   |
|---|---|
|테스트 1 〉|통과 (0.01ms, 4.21MB)|
|테스트 2 〉|통과 (0.02ms, 3.66MB)|
|테스트 3 〉|통과 (0.01ms, 3.59MB)|
|테스트 4 〉|통과 (0.02ms, 4.2MB)|
|테스트 5 〉|통과 (0.02ms, 4.13MB)|
|테스트 6 〉|통과 (0.01ms, 3.65MB)|
|테스트 7 〉|통과 (0.02ms, 3.73MB)|
|테스트 8 〉|통과 (0.01ms, 3.68MB)|
|테스트 9 〉|통과 (0.01ms, 4.14MB)|
|테스트 10 〉|통과 (0.01ms, 3.66MB)|

효율성  테스트

|   |   |
|---|---|
|테스트 1 〉|통과 (1.68ms, 3.84MB)|
|테스트 2 〉|통과 (1.64ms, 3.86MB)|
|테스트 3 〉|통과 (1.77ms, 3.91MB)|
|테스트 4 〉|통과 (1.60ms, 3.91MB)|
|테스트 5 〉|통과 (1.38ms, 3.87MB)|
|테스트 6 〉|통과 (1.36ms, 3.87MB)|
|테스트 7 〉|통과 (1.39ms, 3.87MB)|
|테스트 8 〉|통과 (1.34ms, 3.71MB)|

채점 결과

정확성: 55.6

효율성: 44.4

합계: 100.0 / 100.0